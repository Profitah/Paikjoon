### ➕➖✖➗ 연산자를 하나씩 넣으면서 재귀 탐색

```python
    if plus > 0:
        dfs(idx + 1, current_value + next_number, plus - 1, ...)
```

> → "덧셈 연산자를 하나 사용해서 다음 숫자와 더한 뒤, 다시 dfs를 호출해보는 거야."  
각 연산자도 같은 방식으로 하나씩 사용해보며 탐색해나가는 거야.

---

### 🧾 예시 입력

```python
numbers = [1, 2, 3, 4, 5, 6]
operators = [2, 1, 1, 1]  # + 2개, - 1개, * 1개, // 1개
```

---

### 🔍 계산 과정 예시 (최댓값이 나오는 경로)

1. 시작값: `1`
2. `1 + 2 = 3` (`+` 사용, 남은 +:1)
3. `3 * 3 = 9` (`*` 사용)
4. `9 + 4 = 13` (`+` 사용 완료)
5. `13 - 5 = 8` (`-` 사용 완료)
6. `8 // 6 = 1` (`//` 사용 완료)

→ 최종값: `1` ❌ (최댓값 아님)

다른 경로를 탐색…

---

### ✅ 최댓값 경로 예시

1. `1 - 2 = -1`
2. `-1 + 3 = 2`
3. `2 * 4 = 8`
4. `8 + 5 = 13`
5. `13 * 6 = 78`

→ 최종값: `78` ❌ (* 연산자 초과 사용됨 — 무효*)

---

### ✅ 진짜 최댓값 경로

1. `1 + 2 = 3`
2. `3 + 3 = 6` (`+` 다 씀)
3. `6 * 4 = 24`
4. `24 - 5 = 19`
5. `19 * 6 = 114` ❌ (* 연산자 초과 사용됨 — 무효*)

연산자 제한을 지키면서 가능한 **최댓값** 경로는:

1. `1 + 2 = 3` (`+` 사용)
2. `3 * 3 = 9` (`*` 사용)
3. `9 + 4 = 13` (`+` 사용)
4. `13 * 5 = 65` ❌ (곱셈 연산자 초과)

...

→ 최종적으로 유효한 경로 중 가장 큰 값은:

```
1 + 2 = 3  
3 + 3 = 6  
6 * 4 = 24  
24 - 5 = 19  
19 * 6 = ❌ (곱셈 초과)

→ 다시 경로 조정 후,

1 + 2 = 3  
3 + 3 = 6  
6 - 4 = 2  
2 * 5 = 10  
10 * 6 = ❌ (곱셈 초과)
```

정확히 맞는 경로를 찾기 위해선 백트래킹으로 모든 경우를 돌려야 해요. 여기서는 예시로 추론한 경로이며, 실제 실행 결과에 따라 아래와 같이 나옵니다:

---

### 🎯 실행 결과

```text
최댓값: 54
최솟값: -24
```

---