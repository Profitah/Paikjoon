이 문제는 **숫자들 사이에 연산자들을 끼워넣어서 나올 수 있는 모든 경우의 결과값 중에 최대, 최소를 찾는 문제야.**
---

## 🧠 전체 흐름 먼저 설명할게
1. **숫자 리스트**와  
2. **각 연산자의 개수**가 주어져.  
3. 이걸 가지고 **가능한 모든 연산 조합을 시도해서**,  
4. 계산 결과 중 **최댓값과 최솟값을 구하는 게 목표**야!

---
### 🔢 입력받기
```python
N = int(input())  # 숫자 몇 개인지 받아
numbers = list(map(int, input().split()))  # 숫자들을 받아
plus, minus, multiply, divide = map(int, input().split())  # 연산자 개수 받아
```
> → "자, 이제 숫자들, 그리고 덧셈/뺄셈/곱셈/나눗셈 몇 개 있는지 다 준비됐어!"
---

### 🧾 결과 저장용 리스트 만들기
```python
result = [-1e9, 1e9]  # [최댓값, 최솟값] 저장할 리스트
```
> → "얘는 나중에 계산 결과 중 최고랑 최저를 담아줄 리스트야. 처음엔 말도 안 되게 큰 수/작은 수 넣어둬."
1e9 → 10^9 → 1000000000.0 (십억)<br>
-1e9 → -1000000000.0 (-십억)<br>
비교할 값이 최댓값 보다 크거나 최솟값보다 작으면 변수가 갱신되지 않으므로 입력될 수보다 작거나 클 확률이 높은 수를 입력 해 둬야해.
---

### 🌀 DFS 함수 정의
```python
def dfs(idx, current_value, plus, minus, multiply, divide, result):
```
> → "이 함수는 재귀적으로 모든 경우를 탐색하면서 계산해주는 야."
```python
    if idx == N:
        result[0] = max(result[0], current_value)
        result[1] = min(result[1], current_value)
        return
```
> → 배열의 0번째 인덱스 값부터 마지막 인덱스 값까지 차례로 탐색하면서 현재값과 배열의 인덱스값을 비교하고, <br>
주어진 연산자들을 재귀적으로 적용해 max값과 min값을 적용해주는 함수야. <br>
(전개 과정에 대해서는 다른 파일을 참조할 것)

### ➕➖✖➗ 연산자를 하나씩 넣으면서 재귀 탐색
```python
    if plus > 0:
        dfs(idx + 1, current_value + next_number, plus - 1, ...)
```
> → "덧셈을 하나 써서 다음 숫자와 더해보고, 다시 dfs 함수를 돌려봐."
각각 다른 연산자도 마찬가지 방식으로 하나씩 써보는 거야.


```
좋아요! 그럼 이제 `numbers = [1, 2, 3]`, `operators = [1, 1, 1, 0]` (덧셈, 뺄셈, 곱셈 각각 1개씩)인 상황에서 **DFS 재귀 탐색 트리 구조**를 그려볼게요.

---

## 🌳 DFS 탐색 트리 구조

우리는 `dfs(idx=1, current_value=1)`에서 시작합니다.  
즉, 첫 숫자 `1`을 기준으로 다음 숫자(`2`)와 어떤 연산을 할지를 선택하며 내려갑니다.

```
                            1
                   ┌────────┼────────┐
                   ↓        ↓        ↓
                1 + 2     1 - 2     1 * 2
                 =3         =-1       =2
              ┌───┼───┐   ┌──┼──┐   ┌──┼──┐
              ↓   ↓   ↓   ↓  ↓  ↓   ↓  ↓  ↓
         3 + 3 3 - 3 3 * 3 -1 + 3 -1 - 3 -1 * 3  ...
          =6    =0    =9     =2    =-4    =-3
```

### 전체 경로 요약 (모든 연산자 조합):

1. `1 + 2 = 3` → `3 + 3 = 6` ✅
2. `1 + 2 = 3` → `3 - 3 = 0` ✅
3. `1 + 2 = 3` → `3 * 3 = 9` ✅
4. `1 - 2 = -1` → `-1 + 3 = 2` ✅
5. `1 - 2 = -1` → `-1 * 3 = -3` ✅
6. `1 * 2 = 2` → `2 + 3 = 5` ✅
7. `1 * 2 = 2` → `2 - 3 = -1` ✅

(※ 각 경로는 연산자 개수 제한에 따라 유효한 경우만 탐색합니다.)

---

## ✅ 최댓값 / 최솟값 다시 확인

- **최댓값:** `9` → `(1 + 2) * 3`
- **최솟값:** `-3` → `(1 - 2) * 3`

---
좋아요! 그럼 `numbers = [1, 2, 3]`이고, 연산자 각각 하나씩 있는 상황에서 가능한 **모든 연산 경로**를 정리해드릴게요.

---

## 📌 입력

```
numbers = [1, 2, 3]

| 연산자 조합     | 수식               | 계산 결과 |
|----------------|--------------------|-----------|
| `+`, `-`       | `(1 + 2) - 3`      | `0`       |
| `+`, `*`       | `(1 + 2) * 3`      | `9`       |
| `-`, `+`       | `(1 - 2) + 3`      | `2`       |
| `-`, `*`       | `(1 - 2) * 3`      | `-3`      |
| `*`, `+`       | `(1 * 2) + 3`      | `5`       |
| `*`, `-`       | `(1 * 2) - 3`      | `-1`      |

---

## ✅ 최댓값 & 최솟값
- **최댓값:** `9` → `(1 + 2) * 3`
- **최솟값:** `-3` → `(1 - 2) * 3`
```


### 나눗셈만 살짝 특별해
```python
if divide > 0:  # 나눗셈 연산자가 하나 이상 남아 있다면
    if current_value < 0:  # 현재 값이 음수라면 (파이썬의 //는 내림이라 C++과 결과가 다름)
        # 음수인 경우 절댓값으로 나눈 뒤 부호를 다시 붙여서 C++처럼 처리
        dfs(idx + 1, -(-current_value // next_number), plus, minus, multiply, divide - 1)
    else:
        # 양수인 경우는 그냥 // 사용해도 C++과 동일하므로 그대로 사용
        dfs(idx + 1, current_value // next_number, plus, minus, multiply, divide - 1)
```

> → "파이썬에서 음수를 나누면 반올림 방향이 달라서, C++ 기준으로 처리해줘야 돼. 이 부분만 살짝 신경 써야 해." (문제에서 요구하는 것이 나눗셈을 c++처럼 처리하는 것임으로)
```python
a = -7 , b = 3
print(a // b)

# 결과 : -3
```

```c++
#include <iostream>
using namespace std;

int main() {
    int a = -7;
    int b = 3;
    cout << a / b << endl;
    return 0;
}

// 결과 : -2
```

```
→ "파이썬에서 음수를 나누면 반올림 방향이 달라서, C++ 기준으로 처리해줘야 돼. 

1. 파이썬의 // : 내림(floor) 나눗셈 → 결과를 무조건 작은 쪽으로 반올림

2. C++의 / : 0 방향으로 버림 → 소수점 이하를 그냥 잘라버림 (소수점 제거)

=> 나머지를 0 방향으로 버리도록 하자.
```

---

### 실행 시작

```python
dfs(1, numbers[0], plus, minus, multiply, divide, result)
```

> →  "첫 번째 숫자(numbers[0])는 기준값으로 고정해두고, 두 번째 숫자부터 하나씩 연산자를 적용하면서 가능한 모든 경우를 탐색해보는 거야."



---

### 📢 마지막으로 결과 출력
```python
print(int(result[0]))  
print(int(result[1])) 
```
→ "이제 다 해봤으니, 최댓값이랑 최솟값을 출력해주자!"
연산을 해가면서 최댓값과 최솟값이 갱신될 때마다 result 배열에 저장했었는데,
이때 왼쪽(result[0])엔 최댓값, 오른쪽(result[1])엔 최솟값이 저장되니까
이 점을 감안해서 출력해주면 돼.
--

~ (여기서 부터는안해도 될듯) ~
## 🧩 친구에게 던질 요약
> "DFS는 ‘모든 가능성’을 하나하나 다 해보는 방식이야. <br>
이 문제에선 덧셈/뺄셈/곱셈/나눗셈이 각각 몇 개 있는지 주어지고,  <br>
그걸 각각 어떤 순서로 넣느냐에 따라 결과가 다르니까,  <br>
그걸 다 돌면서 최댓값/최솟값을 찾는 거야!"<br>
<br>
N = 3  <br>
numbers = [3, 4, 5] <br>
연산자: + 1개, * 1개, - 0개, / 0개 <br>
<br>
좋아! 그럼 **도식화(계산 트리)** 와 **예시 계산 순서** 두 가지 방식으로 설명해볼게 👇

---

## 🔸 도식화: DFS가 어떻게 가지를 뻗어나가는지 (계산 트리 예시) 

예시 입력:

```
N = 3  
numbers = [3, 4, 5]  
연산자: + 1개, * 1개, - 0개, / 0개
```

### 계산 트리 구조 (DFS)

```
         3
        / \
      +     *
     /       \
    7         12
   /           \
  *             +
 /               \
35               17
```

- 처음 시작은 `3`
- 그다음 `+`를 써서 `3 + 4 = 7`, 다음은 `*` → `7 * 5 = 35`
- 또는 `*`를 써서 `3 * 4 = 12`, 다음은 `+` → `12 + 5 = 17`

---

## 🔹 DFS 계산 순서 예시
다음 예시를 보자:
```
N = 4
numbers = [1, 2, 3, 4]
연산자: + 2개, - 1개, * 0개, / 0개
```

### 가능한 연산 조합들 (DFS로 모든 조합 탐색)
- 1 + 2 + 3 - 4 → ((1 + 2) + 3) - 4 = 2
- 1 + 2 - 3 + 4 → ((1 + 2) - 3) + 4 = 4
- 1 - 2 + 3 + 4 → ((1 - 2) + 3) + 4 = 6

DFS는 이 **모든 경우**를 차례대로 `idx`를 하나씩 올려가며 시도함.  
매번 결과를 `current_value`로 유지하면서, `연산자 수`를 하나씩 줄여가며 가지를 뻗음.
---

## **🔸 결론 (한 문장 요약)**
- DFS(깊이 우선 탐색)는 한 경로를 끝까지 파고든 뒤,
-  다시 돌아와 다른 경로도 시도해보는 방식이야.
- 이 문제에서는 숫자 idx를 하나씩 옮기면서,
- 연산자를 하나씩 소진해 가며,
- 모든 계산 경로를 탐색해서,
- 최댓값과 최솟값을 업데이트하는 데 사용돼!

