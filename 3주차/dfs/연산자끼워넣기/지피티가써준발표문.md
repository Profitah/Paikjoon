이 문제는 **숫자들 사이에 연산자들을 끼워넣어서 나올 수 있는 모든 경우의 결과값 중에 최대, 최소를 찾는 문제야.**

---

## 🧠 전체 흐름 먼저 설명할게

1. **숫자 리스트**와  
2. **각 연산자의 개수**가 주어져.  
3. 이걸 가지고 **가능한 모든 연산 조합을 시도해서**,  
4. 계산 결과 중 **최댓값과 최솟값을 구하는 게 목표**야!

---
### 🔢 입력받기
```python
N = int(input())  # 숫자 몇 개인지 받아
numbers = list(map(int, input().split()))  # 숫자들을 받아
plus, minus, multiply, divide = map(int, input().split())  # 연산자 개수 받아
```
> → "자, 이제 숫자들, 그리고 덧셈/뺄셈/곱셈/나눗셈 몇 개 있는지 다 준비됐어!"

---

### 🧾 결과 저장용 리스트 만들기
```python
result = [-1e9, 1e9]  # [최댓값, 최솟값] 저장할 리스트
```
> → "얘는 나중에 계산 결과 중 최고랑 최저를 담아줄 리스트야. 처음엔 말도 안 되게 큰 수/작은 수 넣어둬."

---

### 🌀 DFS 함수 정의

```python
def dfs(idx, current_value, plus, minus, multiply, divide, result):
```
> → "이 함수는 재귀적으로 모든 경우를 탐색하면서 계산해주는 친구야."

```python
    if idx == N:
        result[0] = max(result[0], current_value)
        result[1] = min(result[1], current_value)
        return
```
> → "모든 숫자를 다 썼으면, 계산된 값으로 최댓값/최솟값을 갱신하고 끝내."

---

### ➕➖✖➗ 연산자를 하나씩 넣으면서 재귀 탐색

```python
    if plus > 0:
        dfs(idx + 1, current_value + next_number, plus - 1, ...)
```

> → "덧셈을 하나 써서 다음 숫자와 더해보고, 다시 dfs 돌려봐."
각각 다른 연산자도 마찬가지 방식으로 하나씩 써보는 거야.

---

### ⚠ 나눗셈만 살짝 특별해

```python
    if divide > 0:
        if current_value < 0:
            dfs(idx + 1, -(-current_value // next_number), ...)
        else:
            dfs(idx + 1, current_value // next_number, ...)
```

> → "파이썬에서 음수 나누면 반올림 방향이 달라서, C++ 기준으로 처리해줘야 돼. 이 부분만 살짝 신경 써야 해."

---

### 🏁 실행 시작

```python
dfs(1, numbers[0], plus, minus, multiply, divide, result)
```

> → "첫 번째 숫자(numbers[0])는 그대로 쓰고, 두 번째 숫자부터 연산을 하나씩 해보는 거야."

---

### 📢 마지막으로 결과 출력

```python
print(int(result[0]))  # 최대
print(int(result[1]))  # 최소
```

> → "이제 다 해봤으니, 최댓값이랑 최솟값을 출력해주자!"

---

## 🧩 친구에게 던질 요약

> "DFS는 ‘모든 가능성’을 하나하나 다 해보는 방식이야.  
이 문제에선 덧셈/뺄셈/곱셈/나눗셈이 각각 몇 개 있는지 주어지고,  
그걸 각각 어떤 순서로 넣느냐에 따라 결과가 다르니까,  
그걸 다 돌면서 최댓값/최솟값을 찾는 거야!"

필요하면 내가 이걸 **도식화**나 **예시 계산 순서**로도 보여줄 수 있어 😊  
추가로 궁금한 부분 있을까?