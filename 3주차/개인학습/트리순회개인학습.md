preorder('A')        ← A 방문 (루트 출력)
│
├── preorder('B')    ← 왼쪽 자식 B 방문
│   ├── preorder('.')  ← B의 왼쪽 자식 없음 → return
│   └── preorder('.')  ← B의 오른쪽 자식 없음 → return
│
└── preorder('C')    ← 오른쪽 자식 C 방문
    ├── preorder('.')  ← C의 왼쪽 자식 없음 → return
    └── preorder('.')  ← C의 오른쪽 자식 없음 → return



      A
     / \
    B   C


전위 순위 예시
(백준예제를 기준으로 )
1. 'A' 출력
2. 'B' 출력 (왼쪽 자식)
3. 'D' 출력 (B의 왼쪽 자식)
4. 'E' 출력 (B의 오른쪽 자식)
5. 'C' 출력 (A의 오른쪽 자식)



좋은 질문입니다! 👏  
바로 정리해드릴게요.

---

## ✅ 질문:  
> 전위 순회할 때 `"."` 값도 순회 대상에 포함되나요?

### 👉 **아니요! `. (점)`은 실제 노드가 아니라 “자식이 없음”을 나타내는 표시**입니다.  
따라서 `.은 출력되지 않고, 해당 분기는 **재귀에서 return만 하고 건너뜁니다.**

---

## ✅ 백준 예제 기준 다시 정리해 볼게요

### 입력 예시 (백준 1991 기준):

```
7
A B C
B D .
C E F
E . .
F . G
D . .
G . .
```

### 트리 구조:

```
        A
       / \
      B   C
     /   / \
    D   E   F
               \
                G
```

---

## ✅ 전위 순회 (루트 → 왼쪽 → 오른쪽)

`preorder('A')`부터 호출하면 실행 순서와 출력은 다음과 같습니다:
아주 좋은 질문이에요! 👏  
**“왜 전위 순회 예시에 F가 안 나왔지?”**라고 느끼신 건  
→ 정확히 **트리의 구조를 전체적으로 파악하고 있다는 뜻**이에요.  

그런데 지금 말씀하신 예시에서 **4번 `E`가 B의 오른쪽 자식이라는 설명이 잘못되었어요.**  
→ 그 때문에 F가 누락된 것처럼 느껴진 거예요.

---

## ✅ 먼저 백준 예제 다시 보겠습니다

```
입력
7
A B C
B D .
C E F
E . .
F . G
D . .
G . .
```

---

## ✅ 트리 구조 다시 시각화

```
        A
       / \
      B   C
     /   / \
    D   E   F
               \
                G
```

- A의 왼쪽: B
- A의 오른쪽: C  
- B의 왼쪽: D  
- B의 오른쪽: 없음
- C의 왼쪽: E  
- C의 오른쪽: F  
- F의 오른쪽: G

---

## ✅ 전위 순회 (루트 → 왼쪽 → 오른쪽)

함수 흐름:

```python
def preorder(node):
    if node == '.':
        return
    print(node, end='')               # 1. 루트 출력
    preorder(tree[node][0])           # 2. 왼쪽 자식
    preorder(tree[node][1])           # 3. 오른쪽 자식
```

---

## ✅ 전위 순회 실제 호출 흐름

| 단계 | 호출                 | 출력 | 설명 |
|------|----------------------|-------|------|
| 1    | `preorder('A')`      | A     | 시작 |
| 2    | `preorder('B')`      | B     | 왼쪽 자식 |
| 3    | `preorder('D')`      | D     | B의 왼쪽 자식 |
| 4    | `preorder('.')`      | -     | D의 왼쪽 없음 |
| 5    | `preorder('.')`      | -     | D의 오른쪽 없음 |
| 6    | `preorder('.')`      | -     | B의 오른쪽 없음 |
| 7    | `preorder('C')`      | C     | A의 오른쪽 자식 |
| 8    | `preorder('E')`      | E     | C의 왼쪽 자식 |
| 9    | `preorder('.')`      | -     | E의 왼쪽 없음 |
|10    | `preorder('.')`      | -     | E의 오른쪽 없음 |
|11    | `preorder('F')`      | F     | C의 오른쪽 자식 ← ❗️ |
|12    | `preorder('.')`      | -     | F의 왼쪽 없음 |
|13    | `preorder('G')`      | G     | F의 오른쪽 자식 |
|14    | `preorder('.')`      | -     | G의 왼쪽 없음 |
|15    | `preorder('.')`      | -     | G의 오른쪽 없음 |

---

## ✅ 최종 전위 순회 출력

```text
A B D C E F G
```

---

## ✅ 질문 정리

| 질문 | 답변 |
|------|------|
| 왜 F가 출력되지 않았나요? | ❗ 예시에서 **E를 B의 오른쪽 자식이라고 잘못 적으셨기 때문입니다.** 실제로 E는 C의 왼쪽 자식, F는 C의 오른쪽 자식이에요. |
| 그러면 F는 언제 출력되나요? | C를 순회할 때, 왼쪽 E 다음에 오른쪽 F가 출력됩니다. |

---

📌 즉, 전위 순회 예시를 올바르게 쓰면 이렇게 됩니다:

### ✅ 수정된 전위 순회 예시 (백준 기준)

1. `'A'` 출력 (루트)
2. `'B'` 출력 (A의 왼쪽 자식)
3. `'D'` 출력 (B의 왼쪽 자식)
4. `'C'` 출력 (A의 오른쪽 자식)
5. `'E'` 출력 (C의 왼쪽 자식)
6. `'F'` 출력 (C의 오른쪽 자식)
7. `'G'` 출력 (F의 오른쪽 자식)

---

더 궁금한 부분이나 순회 흐름을 시각적으로 보고 싶으시면 언제든 말씀해주세요 😊