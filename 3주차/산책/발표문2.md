## 🎤 백준 21606번 – DFS 풀이 발표 대본
안녕하세요, 저는 백준 21606번 **"아침 산책"** 문제를 **DFS 방식으로 풀이한 방법**을 발표하겠습니다.
---

### ✅ 1. 문제 설명

이 문제는 다음과 같습니다:

- N개의 장소가 있고, 각 장소는 실내 또는 실외입니다.
- 그리고 장소들을 연결하는 N-1개의 간선이 주어지며, 구조는 **트리**입니다.
- 우리는 **양 끝이 모두 실내인 경로의 수**를 구해야 합니다.

실외 노드는 중간에 있어도 괜찮지만,  
**시작점과 끝점은 무조건 실내여야 유효한 경로로 인정**된다는 조건이 핵심입니다.

---

### ✅ 2. 풀이 전략

이 문제는 크게 두 가지 방식으로 유효한 경로를 구할 수 있습니다.

#### 🔹 첫 번째는, **직접 연결된 실내 ↔ 실내 간선**을 세는 것입니다.

- 각 실내 노드에 대해 이웃도 실내인 경우 → 유효 경로 1개
- 이건 인접 리스트를 순회하면서 바로 카운트합니다.

#### 🔹 두 번째는, **실외 노드를 통해 연결된 실내 노드 쌍**을 계산하는 것입니다.

- 이 부분이 핵심인데요,  
  실외 노드를 기준으로 DFS를 실행해서,  
  해당 컴포넌트 안에 연결된 실내 노드 수를 셉니다.

- 그리고 실내 노드가 n개라면 → 만들 수 있는 유효한 경로는 `n * (n - 1)`입니다.  
  → 즉, **실내 노드 쌍의 조합 수(cntC2)**를 계산하는 방식입니다.

---

### ✅ 3. 코드 핵심 설명

- 먼저 실내/실외 정보를 정수 리스트로 저장하고,  
- 그래프는 인접 리스트 방식으로 구성합니다.

- DFS 함수에서는 실외 노드 기준으로 인접한 실내 노드를 만나면 `+1`,  
  실외이면서 아직 방문하지 않은 경우는 재귀적으로 DFS를 진행합니다.

- 방문하지 않은 실외 노드에서 DFS를 수행해 연결된 실내 노드 수 `cnt`를 얻고,  
  그걸 `cnt * (cnt - 1)` 공식에 넣어서 경로 개수를 계산합니다.

- 마지막에는 직접 연결된 실내-실내 경로는 **양쪽에서 중복 계산되었기 때문에**,  
  **2로 나누어 출력**해줍니다.

---

### ✅ 4. 시간 복잡도
- 이 코드는 그래프를 한번 순회하고, DFS도 한 번씩만 실행하므로  
  **O(N)** 으로 매우 효율적입니다.  
- 입력이 최대 10만까지 들어올 수 있는데도 무리 없이 처리할 수 있습니다.

---

### ✅ 5. 정리
- 이 문제의 핵심은 "실외 노드를 경유하는 실내 노드 쌍"을 찾는 것인데,  
  DFS를 통해 그 컴포넌트를 정확하게 탐색하면서  
  **불필요한 반복 없이** 유효한 경로를 정확하게 구할 수 있었습니다.

- 실내-실내 연결은 인접 탐색으로,  
  실외를 통한 연결은 DFS로 처리하면서  
  두 조건을 깔끔하게 분리하여 구현한 점이 이 풀이의 장점이라고 생각합니다.

---


   [1](실내)
     |
   [2](실외)
  /     \
[3]     [5]
 |     /   \
[4]   [6]   [7]
(실내) (실내)