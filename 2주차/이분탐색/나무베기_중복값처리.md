백준 2805 이거 왜 오답이냐 
# 중복 검사 함수
def index_check(tree):
    return len(tree) == len(set(tree)) # 나무 리스트의 길이와 중복값을 제거한 리스트의 길이가 같으면 True, 아니면 False 반환

# 입력
N, M = map(int, input().split()) # 나무의 수 N, 집으로 가져가려고 하는 나무의 길이 M
tree = list(map(int, input().split()))  # `N`개의 나무를 리스트로 받음

# 중복값 검사
if not index_check(tree): # 나무 리스트에 중복값이 있다면
    print("중복된 나무의 길이가 있습니다.") # 중복된 나무의 길이가 있다고 출력하고
    exit() # 프로그램 종료

# 이진 탐색 사용을 위한 준비
tree.sort() # 이진 탐색을 수행하기 위해서는 반드시 정렬해야함.

# 나무 자르기 함수
def tree_cutting(M, tree):# 이분 탐색을 실행한다. 나무의 길이에서 나무리스트의 길이 만큼을 인자로 받는다.
    pl = 0 # 나무의 최소 길이 (이분 탐색 좌측 포인터)
    pr = max(tree) # 나무의 최대 길이 (이분 탐색 우측 포인터)
    h = 0 #  가장 알맞은 절단기 높이

    while pl <= pr: # 좌측 포인터가 우측 포인터보다 작거나 같을 때까지 (탐색 범위가 남아있을 때까지)
        cursor = (pl + pr) // 2 # 중앙 값을 계산하고 (현재 시도해볼 절단기 높이(cursor)를 정한다)
        cut = 0 # 잘린 나무의 길이를 저장할 변수

        for i in tree:  # 나무 리스트에 있는 인덱스를 하나씩 순회하며
            if i > cursor: # 인덱스가 나무가 절단기보다 높으면 자르고
                cut += i - cursor  # 이때 자른 나무의 길이를 누적한다.

        if cut < M: # 잘린 길이가 목표 길이보다 작으면
            pr = cursor - 1 # False를 반환하고, 우측 포인터를 작게 설정
        elif cut > M: # 잘린 길이가 목표 길이보다 크면
            pl = cursor + 1 # True를 반환하고 , 좌측 포인터를 중앙값보다 크게 설정
            h = cursor # 나무의 높이를 저장
        else: # 그 외의 경우 
            return cursor # 중앙값을 반환하고 

    return h # 나무의 높이 반환

if sum(tree) < M: # 나무의 길이가 목표 길이보다 작으면
    print(0) # 0을 출력하고,
else: # 그게 아니라면 
    print(tree_cutting(M, tree)) # 절단기에 설정할 수 있는 최대 높이를 출력한다. 




으아ㅠㅠ 그 맘 알아요... 진짜 미치겠죠  
“**아니 중복 좀 제거한 게 뭐가 어때서!!!!!**” 이런 느낌… 근데 진짜 *백준은 잔인하게도 요구사항 외엔 1도 용납 안 해요*. 😩

---

## 💥 진짜 핵심 이유

이 문제에서 **중복된 나무도 계산 대상이기 때문**이에요.

### 예를 들어볼게요:

입력:
```
5 20
20 15 10 17 17
```

이 상황에서 `17`이 2번 나왔죠?  
당신 코드에선 중복 감지해서 `"중복된 나무의 길이가 있습니다."` 하고 프로그램 종료해버리니까…

➡ **백준 채점 프로그램 입장에선 "얘 왜 출력을 안 하지?" → 오답 처리**

---

## 💡 현실적으로 생각해보면

- **중복 나무**는 현실에서도 많잖아요? 😄  
- 자르기 로직에서는 **같은 길이의 나무가 여러 번 나와야**, `cut += i - cursor`가 **그만큼 더 누적**되는 거죠!

---

## 💡 예시 비교

| 나무 목록         | 커서 | 자른 길이 |
|------------------|------|------------|
| `[20, 15, 10, 17, 17]` | 15   | `5 + 2 + 2 = 9` |
| `[20, 15, 10, 17]`     | 15   | `5 + 2 = 7`     |

→ 중복이 있어야 정답이 되는 입력인데, 그걸 제거하면 값이 틀어짐 ❌

---

## 🔨 정리하자면

### ❌ 하면 안 되는 것
- **중복 제거**
- **중복 확인 후 종료**
- **중복 경고 메시지 출력**

### ✅ 해야 할 것
- **있는 그대로 입력 받기**
- **중복이 있어도 무시하고 그대로 자르기**

---

## 🧠 백준 팁
> “문제에서 시키지 않은 짓은 하지 마라.”  
진짜 백준은 *"오직 문제에 있는 요구사항만 따르는 자가 정답을 얻는다."* 이런 느낌이에요ㅋㅋ

---

힘 빠지겠지만, 이건 개발자라면 다 겪는 성장통이에요.  
혹시 정답 처리된 코드도 다시 붙여드릴까요? 😢  
파이팅입니다, 진심으로!