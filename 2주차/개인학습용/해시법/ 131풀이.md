```
x = [5, 6, 14, 20, 29, 34, 37, 51, 69, 75, _, _, _]
     0  1   2   3   4   5   6   7   8   9  10 11 12
```

- 배열 전체 크기: 13
- **정렬된 구간**: 인덱스 0~9 (총 10개)
- 삽입할 값: **35**

우리는 **정렬된 구간**에서만 이진 탐색을 수행해야 하므로,  
탐색 범위는 `left = 0`, `right = 10` (10은 포함하지 않음)입니다.

---

## 🧮 이진 탐색 시뮬레이션 (삽입 위치 찾기)

```python
arr = [5, 6, 14, 20, 29, 34, 37, 51, 69, 75]
target = 35

left = 0
right = 10  # 정렬된 데이터 수
```

| Step | left | right | mid | arr[mid] | 비교 결과          | 조정된 left/right |
|------|------|--------|-----|----------|---------------------|-------------------|
| ①    | 0    | 10     | 5   | 34       | 34 < 35 → 오른쪽 탐색 | left = 6         |
| ②    | 6    | 10     | 8   | 69       | 69 > 35 → 왼쪽 탐색   | right = 8        |
| ③    | 6    | 8      | 7   | 51       | 51 > 35 → 왼쪽 탐색   | right = 7        |
| ④    | 6    | 7      | 6   | 37       | 37 > 35 → 왼쪽 탐색   | right = 6        |

🔚 루프 종료 조건: `left == right == 6`

---

## ✅ 최종 결과

- **삽입 위치는 인덱스 6**
- `x[6]`부터 한 칸씩 뒤로 밀고, `x[6]`에 `35`를 넣으면 정렬 유지됨

---

## 💡 삽입 결과

```python
x = [5, 6, 14, 20, 29, 34, 35, 37, 51, 69, 75, _, _]
     0  1   2   3   4   5   6   7   8   9  10
```

---

## 📝 정리

- 이진 탐색은 `O(log n)`으로 빠르게 삽입 위치를 찾음
- 실제 삽입을 위해선 뒤 요소들을 `뒤에서부터` 한 칸씩 밀어줘야 함 → `O(n)`
- 최종 시간복잡도는 `O(log n + n) ≈ O(n)` (삽입까지 포함하면)
